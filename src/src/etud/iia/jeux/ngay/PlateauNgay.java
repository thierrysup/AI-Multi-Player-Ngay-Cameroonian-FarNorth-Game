/* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */package src.etud.iia.jeux.ngay;import java.util.ArrayList;import java.util.Scanner;import src.etud.iia.jeux.alg.AlgoJeu;import src.etud.iia.jeux.modele.CoupJeu;import src.etud.iia.jeux.modele.PlateauJeu;import src.etud.iia.jeux.modele.joueur.Joueur;/** * * @author mercedes */public class PlateauNgay implements PlateauJeu {    /* *********** Paramètres de classe *********** */    public static int joueurCourant;    public Joueur currentPlayer;    public static int partieNumber = 1;    public static int partieNumberOld = 1;    public static int joueurDisqualifier;    /**     * Le joueur que joue "1"     */    private static Joueur joueur1;    /**     * Le joueur que joue "2"     */    private static Joueur joueur2;    /**     * Le joueur que joue "3"     */    private static Joueur joueur3;    /* *********** Attributs  *********** */    /**     * Le plateau à 3 rangées de trous     */    private Trou[] trous;    /*pour le cas des veuves et des grand-mères?*/    private boolean[] diahree;    /**     * Le nombre de graines capturées par chaque joueur (indice 0 : Joueur 1,     * indice 1 : Joueur 2,indice 2 : joueur 3)     */    private int[] score;    /**     * La copy des scores obtenus par chaque joueur...dans le but de faire de     * redistribution plustard....     */    private int[] scoreCopy;    /**     * Tableau contenant les Maximum des trous ayant disposer chaque joueur ;     * pour savoir s'il est en mode recuperation ou colonisation pour afin     * savoir a quel interet il aura droit     */    private int[] nbreTrousMax;    /**     * Copie le nombre de trous remporter precedament avant que celui-ci ne soit     * ecraser     */    private int[] nbreTrousJoueurOldCopy;    /**     * Copie le nombre de trous remporter avant la partie précédente de     * nbreTrousJoueurOldCopy     */    private int[] nbreTrouJoueurOldCopyCopy;    /**     * Garde en memoire le joueur qui vient de jouer     */    private Joueur vientDeJouer;    public Joueur joueurQCom;    /* *********** Classe interne *********** */    /**     * Un trou (case) du jeu     */    private class Trou {        /* *********** Attributs  *********** */        /**         * Le "propriétaire" du trou         */        private Joueur propriétaire;        //**** Colonisation de deux trous nouveaux *****        private boolean trousStockagePSept;        //**** Colonisation d'un trou nouveaux *****        private boolean trousStockageESept;        //**** Colonisation d'un perdu ****              private boolean trousStockageECinq;        //**** Trou ordinaire *****        private boolean trousSimple;        /**         * Le nombre de graines que contient le trou         */        private int nbGraines;        /**         * Une référence vers le trou de gauche (on tourne dans le sens horaire)         */        private Trou voisinGauche;        /**         * Une référence vers le trou de droite (on tourne dans le sens trigo)         */        private Trou voisinDroit;        private boolean premierTour = true;        /* *********** Constructeurs  *********** */        public Trou(Joueur j) {            this(j, 5); // 5 graines pour chaque trou en début de partie        }        public Trou(Joueur j, int nbGraines) {            propriétaire = j;            this.nbGraines = nbGraines;            trousSimple = true;            trousStockagePSept = false;            trousStockageECinq = false;            trousStockageESept = false;        }        /* *********** Gestion des attributs  *********** */        public int getNbGraines() {            return nbGraines;        }        public void setVoisins(Trou voisinGauche, Trou voisinDroit) {            setVoisinGauche(voisinGauche);            setVoisinDroit(voisinDroit);        }        public void setPropriétaire(Joueur propriétaire) {            this.propriétaire = propriétaire;        }        public void setVoisinGauche(Trou voisin) {            voisinGauche = voisin;        }        public Trou getVoisinGauche() {            return voisinGauche;        }        public void setVoisinDroit(Trou voisin) {            voisinDroit = voisin;        }        public Trou getVoisinDroit() {            return voisinDroit;        }        private boolean isPropriétaire(Joueur j) {            return j.equals(propriétaire);        }        public Joueur getPropriétaire() {            return propriétaire;        }        public boolean isTrousStockagePSept() {            return trousStockagePSept;        }        public void setTrousStockagePSept(boolean trousStockagePSept) {            this.trousStockagePSept = trousStockagePSept;        }        public boolean isTrousStockageESept() {            return trousStockageESept;        }        public void setTrousStockageESept(boolean trousStockageESept) {            this.trousStockageESept = trousStockageESept;        }        public boolean isTrousStockageECinq() {            return trousStockageECinq;        }        public void setTrousStockageECinq(boolean trousStockageECinq) {            this.trousStockageECinq = trousStockageECinq;        }        public boolean isTrousSimple() {            return trousSimple;        }        public void setTrousSimple(boolean trousSimple) {            this.trousSimple = trousSimple;        }        /* *********** Autres méthodes  *********** */        /**         * Renvoie une copie du trou         */        public Trou copy() {            return new Trou(propriétaire, nbGraines);        }        /**         * Déclencher un coup : Appeler cette méthode sur le trou joué pour         * ramasser, égrainer et capturer les graines.         */        public void declencherCoup(Joueur joueurActuel) {            if (this.isPropriétaire(joueurActuel)) {                if (this.isTrousStockageESept() && (this.nbGraines >= 9)) {                    score[joueurToInt(joueurActuel)] += 7;                    this.nbGraines -= 7;                    this.setTrousStockageESept(false);                    this.setTrousSimple(true);                } else if (this.isTrousStockageECinq() && (this.nbGraines >= 5)) {                    score[joueurToInt(joueurActuel)] += 5;                    this.nbGraines -= 5;                    this.setTrousStockageECinq(false);                    this.setTrousSimple(true);                }            }            if (nbGraines / 10 != 0) { // Si on fait au moins un tour complet, on garde le trou de départ en mémoire                premierTour = true;                getVoisinDroit().égrainer(nbGraines, joueurActuel, this);            } else {                System.out.println("Kadje le nbre de graines est " + nbGraines);                getVoisinDroit().égrainer(nbGraines, joueurActuel);                nbGraines = 0;            }        }        /**         * Lorsque le coup joué devait affamer l'adversaire, on appelle cette         * méthode sur le trou joué         */        private void declencherCoupSansCapturer(Joueur joueurActuel) {//                 if (nbGraines / 10 != 0) { // Si on fait au moins un tour complet, on garde le trou de départ en mémoire//                    getVoisinDroit().égrainerSansCapturer(nbGraines, joueurActuel, this);//                 } else {            getVoisinDroit().égrainerSansCapturer(nbGraines, joueurActuel);            //   }            nbGraines = 0;        }        private void égrainer(int graines, Joueur joueurActuel) {            System.out.println("Kadje le nbre de graines a l'interieur est " + graines);            if (this.getPropriétaire().isGrandeMere() && score[joueurToInt(this.getPropriétaire())] < 6 && diahree[joueurToInt(this.getPropriétaire())]) {                score[joueurToInt(this.getPropriétaire())] += 1;                this.nbGraines = 0;                //graines = graines - 1;            }            switch (graines) {                case 0:                    throw new IllegalArgumentException("Aucune graine à distribuer");                case 1:                    if (this.getPropriétaire().isGrandeMere() && score[joueurToInt(this.getPropriétaire())] < 6 && diahree[joueurToInt(this.getPropriétaire())]) {                        capturer(joueurActuel);                    } else {                        nbGraines++;                        capturer(joueurActuel);                    }                    break;                default:                    if (this.getPropriétaire().isGrandeMere() && score[joueurToInt(this.getPropriétaire())] < 6 && diahree[joueurToInt(this.getPropriétaire())]) {                        getVoisinDroit().égrainer(graines - 1, joueurActuel);                    } else {                        nbGraines++;                        getVoisinDroit().égrainer(graines - 1, joueurActuel);                    }                    break;            }        }        //renplissage d'un Tour apres la fin d'une partie        public void remplirTrou() {            if (isPropriétaire(joueur1)) {                if (scoreCopy[joueurToInt(joueur1)] > 5) {                    this.nbGraines = 5;                    scoreCopy[joueurToInt(joueur1)] = scoreCopy[joueurToInt(joueur1)] - 5;                } else {                    this.nbGraines = scoreCopy[joueurToInt(joueur1)];                    scoreCopy[joueurToInt(joueur1)] = 0;                }                if (searchCase(getVoisinDroit()) != 0) {                    getVoisinDroit().remplirTrou();                }            } else if (isPropriétaire(joueur2)) {                if (scoreCopy[joueurToInt(joueur2)] > 5) {                    this.nbGraines = 5;                    scoreCopy[joueurToInt(joueur2)] = scoreCopy[joueurToInt(joueur2)] - 5;                } else {                    this.nbGraines = scoreCopy[joueurToInt(joueur2)];                    scoreCopy[joueurToInt(joueur2)] = 0;                }                if (searchCase(getVoisinDroit()) != 0) {                    getVoisinDroit().remplirTrou();                }            } else {                if (scoreCopy[joueurToInt(joueur3)] > 5) {                    this.nbGraines = 5;                    scoreCopy[joueurToInt(joueur3)] = scoreCopy[joueurToInt(joueur3)] - 5;                } else {                    this.nbGraines = scoreCopy[joueurToInt(joueur3)];                    scoreCopy[joueurToInt(joueur3)] = 0;                }                if (searchCase(getVoisinDroit()) != 0) {                    getVoisinDroit().remplirTrou();                }            }        }        private void égrainer(int graines, Joueur joueurActuel, Trou trouJoué) {            if (this.equals(trouJoué) && (premierTour == true)) {                this.nbGraines = 0;                trous[searchCase(trouJoué)].nbGraines = 0;                premierTour = false;            }            switch (graines) {                case 0:                    throw new IllegalArgumentException("Aucune graine à distribuer");                case 1:                    nbGraines++;                    capturer(joueurActuel);                    break;                default:                    nbGraines++;                    getVoisinDroit().égrainer(graines - 1, joueurActuel, trouJoué);                    break;            }        }        private void égrainerSansCapturer(int graines, Joueur joueurActuel) {            switch (graines) {                case 0:                    throw new IllegalArgumentException("Aucune graine à distribuer");                case 1:                    nbGraines++;                    capturer(joueurActuel);//new                    break;                default:                    nbGraines++;                    getVoisinDroit().égrainerSansCapturer(graines - 1, joueurActuel);                    break;            }        }        private void égrainerSansCapturer(int graines, Joueur joueurActuel, Trou trouJoué) {            switch (graines) {                case 0:                    throw new IllegalArgumentException("Aucune graine à distribuer");                case 1:                    nbGraines++;                    capturer(joueurActuel);//new                    break;                default:                    nbGraines++;                    getVoisinDroit().égrainer(graines - 1, joueurActuel, trouJoué);            }        }        public int searchCase(Trou t) {            for (int i = 0; i < 10; i++) {                if (trous[i].equals(t)) {                    return i;                }            }            return -1;        }        private void capturer(Joueur joueurActuel) {            if ((nbGraines == 2 || nbGraines == 4) && (this.getPropriétaire().getNombreTrou() > 1) || (nbGraines == 2 || nbGraines == 4) && (this.getPropriétaire().getNombreTrou() == 1) && (diahree[joueurToInt(this.getPropriétaire())])) {                addToScore(nbGraines, joueurActuel);                scoreCopy = score.clone();                nbGraines = 0;                if ((searchCase(getVoisinDroit()) != 5 && searchCase(getVoisinDroit()) != 0) && (getVoisinDroit().nbGraines == 2 || getVoisinDroit().nbGraines == 4)) {                    getVoisinDroit().capturer(joueurActuel);                }            } else if ((getVoisinDroit().nbGraines == 2 || getVoisinDroit().nbGraines == 4) && (getVoisinDroit().getPropriétaire().getNombreTrou() > 1) || (getVoisinDroit().nbGraines == 2 || getVoisinDroit().nbGraines == 4) && (getVoisinDroit().getPropriétaire().getNombreTrou() == 1) && (diahree[joueurToInt(getVoisinDroit().getPropriétaire())])) {                if (searchCase(getVoisinDroit()) != 5 && searchCase(getVoisinDroit()) != 0) {                    getVoisinDroit().capturer(joueurActuel);                }            }        }        private void capturerLeReste(Joueur joueur) {            if (isPropriétaire(joueur)) {                addToScore(nbGraines, joueur);                scoreCopy = score.clone();                nbGraines = 0;                getVoisinDroit().capturerLeReste(joueur);            }        }    }    // FIN DE LA CLASSE Trou    /**     * *********** Constructeurs ***************     */    public PlateauNgay(Joueur joueurQuiCommence) {        joueurQCom = joueurQuiCommence;        currentPlayer = joueurQCom;        vientDeJouer = getJoueurAdverse(joueurQuiCommence);        score = new int[3];        scoreCopy = new int[3];//         nbreTrousMax = new int[3];        nbreTrousJoueurOldCopy = new int[3];        nbreTrouJoueurOldCopyCopy = new int[3];        diahree = new boolean[3];        diahree[0] = false;        diahree[1] = false;        diahree[2] = false;        score[0] = 0;        score[1] = 0;        score[2] = 0;        this.scoreCopy = this.score.clone();        trous = new Trou[10];        for (int i = 0; i < this.joueur1.getNombreTrou(); i++) {            trous[i] = new Trou(PlateauNgay.joueur1);        }        for (int i = this.joueur1.getNombreTrou(); i < (this.joueur1.getNombreTrou() + this.joueur2.getNombreTrou()); i++) {            trous[i] = new Trou(PlateauNgay.joueur2);        }        for (int i = (this.joueur1.getNombreTrou() + this.joueur2.getNombreTrou()); i < (this.joueur1.getNombreTrou() + this.joueur2.getNombreTrou() + this.joueur3.getNombreTrou()); i++) {            trous[i] = new Trou(PlateauNgay.joueur3);        }        nbreTrousJoueurOldCopy[joueurToInt(joueur1)] = joueur1.getNombreTrou();        nbreTrousJoueurOldCopy[joueurToInt(joueur2)] = joueur2.getNombreTrou();        nbreTrousJoueurOldCopy[joueurToInt(joueur3)] = joueur3.getNombreTrou();        nbreTrouJoueurOldCopyCopy = nbreTrousJoueurOldCopy.clone();        assignerVoisins();    }    private PlateauNgay(Joueur joueurQuiCommence, Trou[] trous, int[] score) {        joueurQCom = joueurQuiCommence;        currentPlayer = joueurQCom;        vientDeJouer = getJoueurAdverse(joueurQuiCommence);        this.score = new int[3];        this.scoreCopy = new int[3];        nbreTrousMax = new int[3];        nbreTrousJoueurOldCopy = new int[3];        nbreTrouJoueurOldCopyCopy = new int[3];        diahree = new boolean[3];        diahree[0] = false;        diahree[1] = false;        diahree[2] = false;        this.score[0] = score[0];        this.score[1] = score[1];        this.score[2] = score[2];        this.scoreCopy = this.score.clone();        this.trous = new Trou[10];        for (int i = 0; i < 10; i++) {            int ng = trous[i].getNbGraines();            Joueur prop = trous[i].getPropriétaire();            this.trous[i] = new Trou(prop, ng);            //this.trous[i] = trous[i].copy();        }        nbreTrousJoueurOldCopy[joueurToInt(joueur1)] = joueur1.getNombreTrou();        nbreTrousJoueurOldCopy[joueurToInt(joueur2)] = joueur2.getNombreTrou();        nbreTrousJoueurOldCopy[joueurToInt(joueur3)] = joueur3.getNombreTrou();        nbreTrouJoueurOldCopyCopy = nbreTrousJoueurOldCopy.clone();        assignerVoisins();//        System.arraycopy(score, 0, this.score, 0, 2);    }    /**     * *********** Gestion des paramètres de classe *****************     */    public static void setJoueurs(Joueur j1, Joueur j2, Joueur j3) {        joueur1 = j1;        joueur2 = j2;        joueur3 = j3;    }    public Trou[] getTrous() {        return trous;    }    public int[] getScore() {        return score;    }    public int nbreTrou(Joueur j) {        int cmpt = 0;        for (int i = 0; i < 10; i++) {            if (trous[i].isPropriétaire(j)) {                cmpt++;            }        }        return cmpt;    }    public static boolean isJoueur1(Joueur j1) {        return joueur1.equals(j1);    }    public static boolean isJoueur2(Joueur j2) {        return joueur2.equals(j2);    }    public static boolean isJoueur3(Joueur j3) {        return joueur3.equals(j3);    }    public static Joueur getJoueurAdverse(Joueur j) {        if (isJoueur1(j)) // joueur2 : joueur adverse        {            return joueur2;        } else if (isJoueur2(j)) {  // joueur3 : joueur adverse            return joueur3;        } else// joueur1 : joueur adverse        {            return joueur1;        }    }    public static Joueur getJoueur(int indice) {        if (indice == 0) {            return joueur1;        } else if (indice == 1) {            return joueur2;        } else if (indice == 2) {            return joueur3;        }        return null;    }    public static Joueur getJoueur1() {        return joueur1;    }    public static void setJoueur1(Joueur joueur1) {        PlateauNgay.joueur1 = joueur1;    }    public static Joueur getJoueur2() {        return joueur2;    }    public static void setJoueur2(Joueur joueur2) {        PlateauNgay.joueur2 = joueur2;    }    public static Joueur getJoueur3() {        return joueur3;    }    public static void setJoueur3(Joueur joueur3) {        PlateauNgay.joueur3 = joueur3;    }    /**     * Retourne l'indice du tableau score correspondant à un joueur     */    public static int joueurToInt(Joueur j) {        if (isJoueur1(j)) {    // Joueur 1, indice 0            return 0;        } else if (isJoueur2(j)) {                  // Joueur 2, indice 1            return 1;        } else // Joueur 3, indice 2        {            return 2;        }    }    public static float[] vector_Max(float[] v1, float[] v2, Joueur player) {        if (v1[joueurToInt(player)] == v2[joueurToInt(player)]) {            return v1;        } else {            float vMax = Math.max(v1[joueurToInt(player)], v2[joueurToInt(player)]);            if (v1[joueurToInt(player)] == vMax) {                return v1;            } else {                return v2;            }        }    }    /**     *     * Le jeux de la machine     *     */    public void launchGameAI(Joueur joueur, AlgoJeu[] al) {        if (joueur.getNombreTrou() == 1) {            diahree[joueurToInt(joueur)] = true;        }        ArrayList<CoupNgay> lesCoupsPossibles = this.coupsPossibles(joueur);        CoupNgay meilleurCoup = null;        meilleurCoup = al[joueurToInt(joueur)].meilleurCoupMultiPlayer(this, joueur);        System.out.println("le meilleur cout est " + meilleurCoup);        System.out.println("avant jouer AI");        joue(joueur, meilleurCoup);        System.out.println("avant jouer AI");    }    /**     *     * Le jeu de L'Humain     *     */    public void launchGamePlayer(Joueur joueur, CoupNgay coup) {        if (joueur.getNombreTrou() == 1) {            diahree[joueurToInt(joueur)] = true;        }        System.out.println("avant jouer");        joue(joueur, coup);        System.out.println("apres.. jouer");    }    /**     *     * Fin de partie et Prochain joueur des le depart en cas de manque de coup     *     * @param joueur     */    public void updateTableGame(Joueur joueur) {        if (pasDeCoupPossibles(joueur1) && pasDeCoupPossibles(joueur2) && pasDeCoupPossibles(joueur3)) {            trous[0].capturerLeReste(joueur1);            trous[(nbreTrou(joueur1)) % 10].capturerLeReste(joueur2);            trous[(nbreTrou(joueur1) + nbreTrou(joueur2)) % 10].capturerLeReste(joueur3);            partieNumberOld = partieNumber;            if (!finPartieNgay()) {                partieNumber += 1;                redistributionTrou();                if (joueur1.getNombreTrou() == 0) {                    joueurDisqualifier = 1;                } else {                    if (joueur2.getNombreTrou() == 0) {                        joueurDisqualifier = 2;                    } else {                        if (joueur3.getNombreTrou() == 0) {                            joueurDisqualifier = 3;                        }                    }                }                reclasserTrous();                marquageTrous(joueur);                marquageTrous(next_Player(joueur));                marquageTrous(next_Player(next_Player(joueur)));                diahree[joueurToInt(joueur1)] = false;                diahree[joueurToInt(joueur2)] = false;                diahree[joueurToInt(joueur3)] = false;                score[0] = 0;                score[1] = 0;                score[2] = 0;                widowGrandMotherTransformation(joueur);                widowGrandMotherTransformation(next_Player(joueur));                widowGrandMotherTransformation(next_Player(next_Player(joueur)));                scoreCopy = score.clone();                joueurQCom = next_Player(joueurQCom);                System.out.println("je passe au joueur " + joueurQCom.toString());//                if(joueurQCom.equals(PlateauNgay.joueur1)){//                    //                }            }//finf du jeuxu jeu Ngay        } else {            currentPlayer = next_Player(joueur);        }    }    /**     *     * *********** Lancer le tour du jeux a chaque joueur ***********     *     * @param joueur     * @param al     */    //ajouter un paramètre du joueur algo.    public void lancerJoueur(Joueur joueur, AlgoJeu[] al) {        if (joueur.getNombreTrou() == 1) {            diahree[joueurToInt(joueur)] = true;        }        float oldScore = score[joueurToInt(joueur)];        ArrayList<CoupNgay> lesCoupsPossibles = this.coupsPossibles(joueur);        System.out.println("Coups possibles pour le Joueur " + (joueurToInt(joueur) + 1) + " : " + lesCoupsPossibles);//tester si c'est le joueur algo avant de choisir le meilleur coups.        CoupNgay meilleurCoup = null;        CoupNgay coupJouer = new CoupNgay(0);        if (isJoueur1(joueur)) {            meilleurCoup = al[joueurToInt(joueur)].meilleurCoupMultiPlayer(this, joueur);            System.out.println("le meilleur coup jouer est " + meilleurCoup + " par le joueur " + (joueurToInt(joueur) + 1));            this.joue(joueur, meilleurCoup);            //iniNgayTAble();            System.out.println("Apres ce coup du joueur " + (joueurToInt(joueur) + 1) + " : score = " + score[joueurToInt(joueur)] + " gains = " + (score[joueurToInt(joueur)] - oldScore));        } else {            boolean exite = false;            Scanner sc = new Scanner(System.in);            System.out.print("Veuillez saisir le numéro de votre cout :");            int str = sc.nextInt();            coupJouer.setIndiceTrou(str - 1);            System.out.println(str);            coupJouer.toString();            for (CoupNgay coupJoue : lesCoupsPossibles) {                if (coupJouer.getIndiceTrou() == coupJoue.getIndiceTrou()) {                    exite = true;                    break;                }            }            if (exite == true) {                this.joue(joueur, coupJouer);                System.out.println("Apres ce coup du joueur " + (joueurToInt(joueur) + 1) + " : score = " + score[joueurToInt(joueur)] + " gains = " + (score[joueurToInt(joueur)] - oldScore));            } else {                System.out.println("Coup non valide");            }        }    }    /**     * *********** Jouer le jeux dans l'interface     *     ***************     * @param joueur     * @param al     */    public void jouer(Joueur joueur, AlgoJeu[] al) {        if (!pasDeCoupPossibles(joueur)) {            System.out.println("\n" + "C'est au joueur numero " + (joueurToInt(joueur) + 1) + " de jouer.");            joueurCourant = joueurToInt(joueur) + 1;            System.out.println("" + this);            System.out.println("Recherche du meilleur coup avec l'algo " + al[joueurToInt(joueur)]);            this.lancerJoueur(joueur, al);            //   System.out.println("next player " + next_Player(joueur));            jouer(next_Player(joueur), al);        } else if (pasDeCoupPossibles(joueur) && pasDeCoupPossibles(next_Player(joueur)) && pasDeCoupPossibles(next_Player(next_Player(joueur)))) {            System.out.println(" ***** FIN de la partie ***** ");            System.out.println("" + this + "\n");            trous[0].capturerLeReste(joueur1);            trous[(nbreTrou(joueur1)) % 10].capturerLeReste(joueur2);            trous[(nbreTrou(joueur1) + nbreTrou(joueur2)) % 10].capturerLeReste(joueur3);            System.out.println(" ***** Apres le ramassage des pions par chaque proprietaire ***** ");            System.out.println("" + this + "\n");            System.out.println("Le joueur " + (1) + " a capturé " + this.getScore(joueur1) + " graines");            System.out.println("Le joueur " + (2) + " a capturé " + this.getScore(joueur2) + " graines");            System.out.println("Le joueur " + (3) + " a capturé " + this.getScore(joueur3) + " graines");            System.out.println("Le joueur " + (1) + " a capturé en copy " + this.getScoreCopy(joueur1) + " graines");            System.out.println("Le joueur " + (2) + " a capturé en copy " + this.getScoreCopy(joueur2) + " graines");            System.out.println("Le joueur " + (3) + " a capturé en copy " + this.getScoreCopy(joueur3) + " graines");            if (!this.finPartieNgay()) {                partieNumber += 1;                redistributionTrou();                if (joueur1.getNombreTrou() == 0) {                    joueurDisqualifier = 1;                } else {                    if (joueur2.getNombreTrou() == 0) {                        joueurDisqualifier = 2;                    } else {                        if (joueur3.getNombreTrou() == 0) {                            joueurDisqualifier = 3;                        }                    }                }                reclasserTrous();                marquageTrous(joueur);                marquageTrous(next_Player(joueur));                marquageTrous(next_Player(next_Player(joueur)));                diahree[joueurToInt(joueur1)] = false;                diahree[joueurToInt(joueur2)] = false;                diahree[joueurToInt(joueur3)] = false;                score[0] = 0;                score[1] = 0;                score[2] = 0;                widowGrandMotherTransformation(joueur);                widowGrandMotherTransformation(next_Player(joueur));                widowGrandMotherTransformation(next_Player(next_Player(joueur)));                scoreCopy = score.clone();                System.out.println("Le joueur " + (1) + " a " + coupsPossibles(joueur1) + " coups possibles");                System.out.println("Le joueur " + (2) + " a " + coupsPossibles(joueur2) + " coups possibles");                System.out.println("Le joueur " + (3) + " a " + coupsPossibles(joueur3) + " coups possibles");            }        } else {            jouer(next_Player(joueur), al);        }    }    /**     * *********** Accesseurs     *     ***************     * @param j     * @return     */    public int getScore(Joueur j) {        return score[joueurToInt(j)];    }    public int getNbGraines(int i) {        return trous[i].getNbGraines();    }    public int getScoreCopy(Joueur j) {        return scoreCopy[joueurToInt(j)];    }    /**     * Methode qui marque tous les Trous de type Stockage     *     * @param player     */    public void marquageTrous(Joueur player) {        if (player.getNombreTrou() > 1) {            if (player.getNombreTrou() > nbreTrousJoueurOldCopy[joueurToInt(player)]) {                int Difference = player.getNombreTrou() - nbreTrousJoueurOldCopy[joueurToInt(player)];                if ((player.getNombreTrou() - nbreTrousJoueurOldCopy[joueurToInt(player)]) == 1) {                    int difference1 = nbreTrousJoueurOldCopy[joueurToInt(player)] - nbreTrouJoueurOldCopyCopy[joueurToInt(player)];                    if ((nbreTrousJoueurOldCopy[joueurToInt(player)] - nbreTrouJoueurOldCopyCopy[joueurToInt(player)]) >= 0) {                        //ramasse de 7;                        if (this.isJoueur1(player)) {                            trous[0].setTrousStockageESept(true);                            trous[0].setTrousSimple(false);                        } else if (this.isJoueur2(player)) {                            trous[joueur1.getNombreTrou() % 10].setTrousStockageESept(true);                            trous[joueur1.getNombreTrou() % 10].setTrousSimple(false);                        } else {                            trous[(joueur1.getNombreTrou() + joueur2.getNombreTrou()) % 10].setTrousStockageESept(true);                            trous[(joueur1.getNombreTrou() + joueur2.getNombreTrou()) % 10].setTrousSimple(false);                        }                    } else //ramasse de 5;                    if (this.isJoueur1(player)) {                        trous[0].setTrousStockageECinq(true);                        trous[0].setTrousSimple(false);                    } else if (this.isJoueur2(player)) {                        trous[joueur1.getNombreTrou() % 10].setTrousStockageECinq(true);                        System.out.println("marquage du trou" + joueur1.getNombreTrou() % 10);                        trous[joueur1.getNombreTrou() % 10].setTrousSimple(false);                    } else {                        trous[(joueur1.getNombreTrou() + joueur2.getNombreTrou()) % 10].setTrousStockageECinq(true);                        trous[(joueur1.getNombreTrou() + joueur2.getNombreTrou()) % 10].setTrousSimple(false);                    }                } else if (nbreTrousJoueurOldCopy[joueurToInt(player)] - nbreTrouJoueurOldCopyCopy[joueurToInt(player)] >= 0) {                    if (this.isJoueur1(player)) {                        trous[0].setTrousStockagePSept(true);                        trous[0].setTrousSimple(false);                    } else if (this.isJoueur2(player)) {                        trous[joueur1.getNombreTrou() % 10].setTrousStockagePSept(true);                        trous[joueur1.getNombreTrou() % 10].setTrousSimple(false);                    } else {                        trous[(joueur1.getNombreTrou() + joueur2.getNombreTrou()) % 10].setTrousStockagePSept(true);                        trous[(joueur1.getNombreTrou() + joueur2.getNombreTrou()) % 10].setTrousSimple(false);                    }                } else {                    int difference2 = (player.getNombreTrou() - nbreTrousJoueurOldCopy[joueurToInt(player)]) + (nbreTrousJoueurOldCopy[joueurToInt(player)] - nbreTrouJoueurOldCopyCopy[joueurToInt(player)]);                    if (difference2 == 1) {                        int trousAMarque = nbreTrousJoueurOldCopy[joueurToInt(player)] - nbreTrousJoueurOldCopy[joueurToInt(player)];                        int i;                        if (this.isJoueur1(player)) {                            for (i = 0; i < trousAMarque; i++) {                                trous[i].setTrousStockageECinq(true);                                trous[i].setTrousSimple(false);                            }                            trous[i].setTrousStockageESept(true);                            trous[i].setTrousSimple(false);                        } else if (this.isJoueur2(player)) {                            for (i = joueur1.getNombreTrou() % 10; i < (joueur1.getNombreTrou() + trousAMarque) % 10; i++) {                                trous[i].setTrousStockageECinq(true);                                trous[i].setTrousSimple(false);                            }                            trous[i].setTrousStockageESept(true);                            trous[i].setTrousSimple(false);                        } else {                            for (i = (joueur1.getNombreTrou() + joueur2.getNombreTrou()) % 10; i < (joueur1.getNombreTrou() + joueur2.getNombreTrou() + trousAMarque) % 10; i++) {                                trous[i].setTrousStockageECinq(true);                                trous[i].setTrousSimple(false);                            }                            trous[i].setTrousStockageESept(true);                            trous[i].setTrousSimple(false);                        }                    }                    if (difference2 == 0) {                        int trousAMarques = nbreTrousJoueurOldCopy[joueurToInt(player)] - nbreTrousJoueurOldCopy[joueurToInt(player)];                        int i;                        if (this.isJoueur1(player)) {                            for (i = 0; i < trousAMarques; i++) {                                trous[i].setTrousStockageECinq(true);                                trous[i].setTrousSimple(false);                            }                        } else if (this.isJoueur2(player)) {                            for (i = joueur1.getNombreTrou() % 10; i < (joueur1.getNombreTrou() + trousAMarques) % 10; i++) {                                trous[i].setTrousStockageECinq(true);                                trous[i].setTrousSimple(false);                            }                        } else {                            for (i = (joueur1.getNombreTrou() + joueur2.getNombreTrou()) % 10; i < (joueur1.getNombreTrou() + joueur2.getNombreTrou() + trousAMarques) % 10; i++) {                                trous[i].setTrousStockageECinq(true);                                trous[i].setTrousSimple(false);                            }                        }                    }                    if (difference2 >= 2) {                        int trousAMarque = nbreTrousJoueurOldCopy[joueurToInt(player)] - nbreTrousJoueurOldCopy[joueurToInt(player)];                        int i;                        if (this.isJoueur1(player)) {                            for (i = 0; i < trousAMarque; i++) {                                trous[i].setTrousStockageECinq(true);                                trous[i].setTrousSimple(false);                            }                            trous[i].setTrousStockagePSept(true);                            trous[i].setTrousSimple(false);                        } else if (this.isJoueur2(player)) {                            for (i = joueur1.getNombreTrou() % 10; i < (joueur1.getNombreTrou() + trousAMarque) % 10; i++) {                                trous[i].setTrousStockageECinq(true);                                trous[i].setTrousSimple(false);                            }                            trous[i].setTrousStockagePSept(true);                            trous[i].setTrousSimple(false);                        } else {                            for (i = (joueur1.getNombreTrou() + joueur2.getNombreTrou()) % 10; i < (joueur1.getNombreTrou() + joueur2.getNombreTrou() + trousAMarque) % 10; i++) {                                trous[i].setTrousStockageECinq(true);                                trous[i].setTrousSimple(false);                            }                            trous[i].setTrousStockagePSept(true);                            trous[i].setTrousSimple(false);                        }                    }                }            }        }    }    /**     * Methode qui definir le Trou d'une Veuve ou d'une Grande-Mere     */    public void widowGrandMotherTransformation(Joueur player) {        if ((player.getNombreTrou() == 1) && (player.isSimple())) {            for (int i = 0; i < 10; i++) {                if (trous[i].isPropriétaire(player)) {                    trous[i].nbGraines = 3;                    score[joueurToInt(player)] = 2;                    player.setVeuve(true);                    player.setSimple(false);                    break;                }            }        } else if ((player.getNombreTrou() == 1) && (player.isVeuve())) {            for (int i = 0; i < 10; i++) {                if (trous[i].isPropriétaire(player)) {                    trous[i].nbGraines = 4;                    score[joueurToInt(player)] = 1;                    player.setVeuve(false);                    player.setGrandeMere(true);                    player.setSimple(false);                    break;                }            }        } else if ((player.getNombreTrou() == 1) && (player.isGrandeMere())) {            player.setVeuve(false);            player.setGrandeMere(false);            player.setSimple(true);        } else if (player.getNombreTrou() > 1) {            player.setGrandeMere(false);            player.setVeuve(false);            player.setSimple(true);        } else if (player.getNombreTrou() < 1) {            player.setGrandeMere(false);            player.setVeuve(false);            player.setSimple(false);            player.setDead(true);        }    }    /**     * *********** Méthodes de l'interface PlateauJeu ***************     */    public ArrayList<CoupNgay> coupsPossibles(Joueur jo) {        ArrayList<CoupNgay> lesCoupsPossibles = new ArrayList<CoupNgay>();        for (int i = 0; i < 10; i++) {            CoupNgay coup = new CoupNgay(i);            if (coupValide(jo, coup)) {                lesCoupsPossibles.add(coup);            }        }        return lesCoupsPossibles;    }    public void joue(Joueur j, CoupNgay c) {        CoupNgay ca = c;        int indiceTrou = ca.getIndiceTrou();        trous[indiceTrou].declencherCoup(j);        vientDeJouer = j;    }    //-----------------------------------------------    // FIN DE PARTIE  DU NGAY    //-------------------------------------------------    public boolean finPartieNgay() {        if (score[0] >= 48 || score[1] >= 48 || score[2] >= 48) {            return true;        } else {            return false;        }    }    /**     *********** Mise a jour des trous des differents joueur ***********     *     */    public void updateCaseOwner() {        joueur1.setNombreTrou(nbreTrou(joueur1));        joueur2.setNombreTrou(nbreTrou(joueur2));        joueur3.setNombreTrou(nbreTrou(joueur3));    }    /**     * Mise en memoire de nombre de trous le plus elever par joueur     */    public void maxNbreTrou() {        nbreTrousMax[joueurToInt(joueur1)] = Math.max(nbreTrousMax[joueurToInt(joueur1)], joueur1.getNombreTrou());        nbreTrousMax[joueurToInt(joueur2)] = Math.max(nbreTrousMax[joueurToInt(joueur2)], joueur2.getNombreTrou());        nbreTrousMax[joueurToInt(joueur3)] = Math.max(nbreTrousMax[joueurToInt(joueur3)], joueur3.getNombreTrou());    }    /**     * Fonction Redistribution des TRous dans le Plateau     */    public void redistributionTrou() {        trous[0].remplirTrou();//remplissage sequentiel a PARALLELISE plutard...        if (score[0] < (5 * (joueur1.getNombreTrou()))) {            if (score[1] < (5 * (joueur2.getNombreTrou()))) {                for (int i = 0; i < 10; i++) {                    if (trous[i].nbGraines < 5) {                        scoreCopy[2] = scoreCopy[2] + trous[i].nbGraines - 5;                        if (trous[i].nbGraines < 3) {                            trous[i].setPropriétaire(joueur3);                        }                        trous[i].nbGraines = 5;                    }                }            } else if (score[2] < (5 * (joueur3.getNombreTrou()))) {                for (int i = 0; i < 10; i++) {                    if (trous[i].nbGraines < 5) {                        scoreCopy[1] = scoreCopy[1] + trous[i].nbGraines - 5;                        if (trous[i].nbGraines < 3) {                            trous[i].setPropriétaire(joueur2);                        }                        trous[i].nbGraines = 5;                    }                }            } else if (scoreCopy[2] == 0) {                for (int i = 0; i < 10; i++) {                    if (trous[i].nbGraines < 5) {                        scoreCopy[1] = scoreCopy[1] + trous[i].nbGraines - 5;                        if (trous[i].nbGraines < 3) {                            trous[i].setPropriétaire(joueur2);                        }                        trous[i].nbGraines = 5;                    }                }            } else {                for (int i = 0; i < 10; i++) {                    if (trous[i].nbGraines < 5) {                        int eltJ3 = scoreCopy[2];                        scoreCopy[2] = scoreCopy[2] + trous[i].nbGraines - 5;                        if (scoreCopy[2] < 0) {                            trous[i].nbGraines = trous[i].nbGraines + eltJ3;                            scoreCopy[1] = scoreCopy[1] + trous[i].nbGraines - 5;                            if (trous[i].nbGraines < 3) {                                trous[i].setPropriétaire(joueur2);                            } else if (eltJ3 > 2) {                                trous[i].setPropriétaire(joueur3);                            }                            trous[i].nbGraines = 5;                            scoreCopy[2] = 0;                        } else {                            if (trous[i].nbGraines < 3) {                                trous[i].setPropriétaire(joueur3);                            }                            trous[i].nbGraines = 5;                        }                    }                }            }        } else if (score[1] < (5 * (joueur2.getNombreTrou()))) {            if (score[2] < (5 * (joueur3.getNombreTrou()))) {                for (int i = 0; i < 10; i++) {                    if (trous[i].nbGraines < 5) {                        scoreCopy[0] = scoreCopy[0] + trous[i].nbGraines - 5;                        if (trous[i].nbGraines < 3) {                            trous[i].setPropriétaire(joueur1);                        }                        trous[i].nbGraines = 5;                    }                }            } else if (scoreCopy[2] == 0) {                for (int i = 0; i < 10; i++) {                    if (trous[i].nbGraines < 5) {                        scoreCopy[0] = scoreCopy[0] + trous[i].nbGraines - 5;                        if (trous[i].nbGraines < 3) {                            trous[i].setPropriétaire(joueur1);                        }                        trous[i].nbGraines = 5;                    }                }            } else {                for (int i = 0; i < 10; i++) {                    if (trous[i].nbGraines < 5) {                        int eltJ3 = scoreCopy[2];                        scoreCopy[2] = scoreCopy[2] + trous[i].nbGraines - 5;                        if (scoreCopy[2] < 0) {                            trous[i].nbGraines = trous[i].nbGraines + eltJ3;                            scoreCopy[0] = scoreCopy[0] + trous[i].nbGraines - 5;                            if (trous[i].nbGraines < 3) {                                trous[i].setPropriétaire(joueur1);                            } else if (eltJ3 > 2) {                                trous[i].setPropriétaire(joueur3);                            }                            trous[i].nbGraines = 5;                            scoreCopy[2] = 0;                        } else {                            if (trous[i].nbGraines < 3) {                                trous[i].setPropriétaire(joueur3);                            }                            trous[i].nbGraines = 5;                        }                    }                }            }        } else if (scoreCopy[1] == 0) {            for (int i = 0; i < 10; i++) {                if (trous[i].nbGraines < 5) {                    scoreCopy[0] = scoreCopy[0] + trous[i].nbGraines - 5;                    if (trous[i].nbGraines < 3) {                        trous[i].setPropriétaire(joueur1);                    }                    trous[i].nbGraines = 5;                }            }        } else {            for (int i = 0; i < 10; i++) {                if (trous[i].nbGraines < 5) {                    int eltJ2 = scoreCopy[1];                    scoreCopy[1] = scoreCopy[1] + trous[i].nbGraines - 5;                    if (scoreCopy[1] < 0) {                        trous[i].nbGraines = trous[i].nbGraines + eltJ2;                        scoreCopy[0] = scoreCopy[0] + trous[i].nbGraines - 5;                        if (trous[i].nbGraines < 3) {                            trous[i].setPropriétaire(joueur1);                        } else if (eltJ2 > 2) {                            trous[i].setPropriétaire(joueur2);                        }                        trous[i].nbGraines = 5;                        scoreCopy[1] = 0;                    } else {                        if (trous[i].nbGraines < 3) {                            trous[i].setPropriétaire(joueur2);                        }                        trous[i].nbGraines = 5;                    }                }            }        }        nbreTrouJoueurOldCopyCopy = nbreTrousJoueurOldCopy.clone();        nbreTrousJoueurOldCopy[joueurToInt(joueur1)] = joueur1.getNombreTrou();        nbreTrousJoueurOldCopy[joueurToInt(joueur2)] = joueur2.getNombreTrou();        nbreTrousJoueurOldCopy[joueurToInt(joueur3)] = joueur3.getNombreTrou();        // maxNbreTrou();// Recuperer le nombre de trous Max par joueur ...        updateCaseOwner();//mise a jour des proprietaires des Trous ....    }    public void reclasserTrous() {        if ((nbreTrou(joueur1) > 0) && (nbreTrou(joueur2) > 0) && (nbreTrou(joueur3) > 0)) {            for (int i = 0; i < this.joueur1.getNombreTrou(); i++) {                trous[i] = new Trou(PlateauNgay.joueur1);                System.out.println(this.joueur1.getNombreTrou());            }            for (int i = this.joueur1.getNombreTrou(); i < (this.joueur1.getNombreTrou() + this.joueur2.getNombreTrou()); i++) {                trous[i] = new Trou(PlateauNgay.joueur2);                System.out.println(this.joueur2.getNombreTrou());            }            for (int i = (this.joueur1.getNombreTrou() + this.joueur2.getNombreTrou()); i < (this.joueur1.getNombreTrou() + this.joueur2.getNombreTrou() + this.joueur3.getNombreTrou()); i++) {                trous[i] = new Trou(PlateauNgay.joueur3);                System.out.println(this.joueur3.getNombreTrou());            }            assignerVoisins();        } else if ((nbreTrou(joueur1) > 0) && (nbreTrou(joueur2) > 0) && (nbreTrou(joueur3) <= 0)) {            for (int i = 0; i < this.joueur1.getNombreTrou(); i++) {                trous[i] = new Trou(PlateauNgay.joueur1);                System.out.println(this.joueur1.getNombreTrou());            }            for (int i = this.joueur1.getNombreTrou(); i < (this.joueur1.getNombreTrou() + this.joueur2.getNombreTrou()); i++) {                trous[i] = new Trou(PlateauNgay.joueur2);                System.out.println(this.joueur2.getNombreTrou());            }            assignerVoisins();        } else if ((nbreTrou(joueur1) > 0) && (nbreTrou(joueur2) <= 0) && (nbreTrou(joueur3) > 0)) {            for (int i = 0; i < this.joueur1.getNombreTrou(); i++) {                trous[i] = new Trou(PlateauNgay.joueur1);                System.out.println(this.joueur1.getNombreTrou());            }            for (int i = this.joueur1.getNombreTrou(); i < (this.joueur1.getNombreTrou() + this.joueur3.getNombreTrou()); i++) {                trous[i] = new Trou(PlateauNgay.joueur3);                System.out.println(this.joueur3.getNombreTrou());            }            assignerVoisins();        } else if ((nbreTrou(joueur1) > 0) && (nbreTrou(joueur2) <= 0) && (nbreTrou(joueur3) <= 0)) {            for (int i = 0; i < this.joueur1.getNombreTrou(); i++) {                trous[i] = new Trou(PlateauNgay.joueur1);                System.out.println(this.joueur1.getNombreTrou());            }            assignerVoisins();        } else if ((nbreTrou(joueur1) <= 0) && (nbreTrou(joueur2) > 0) && (nbreTrou(joueur3) > 0)) {            for (int i = 0; i < this.joueur2.getNombreTrou(); i++) {                trous[i] = new Trou(PlateauNgay.joueur2);                System.out.println(this.joueur2.getNombreTrou());            }            for (int i = this.joueur2.getNombreTrou(); i < (this.joueur2.getNombreTrou() + this.joueur3.getNombreTrou()); i++) {                trous[i] = new Trou(PlateauNgay.joueur3);                System.out.println(this.joueur3.getNombreTrou());            }            assignerVoisins();        } else if ((nbreTrou(joueur1) <= 0) && (nbreTrou(joueur2) > 0) && (nbreTrou(joueur3) <= 0)) {            for (int i = 0; i < (this.joueur2.getNombreTrou()); i++) {                trous[i] = new Trou(PlateauNgay.joueur2);                System.out.println(this.joueur2.getNombreTrou());            }            assignerVoisins();        } else if ((nbreTrou(joueur1) <= 0) && (nbreTrou(joueur2) <= 0) && (nbreTrou(joueur3) > 0)) {            for (int i = 0; i < (this.joueur3.getNombreTrou()); i++) {                trous[i] = new Trou(PlateauNgay.joueur3);                System.out.println(this.joueur3.getNombreTrou());            }            assignerVoisins();        }    }    public boolean pasDeCoupPossibles(Joueur joueur) {        ArrayList<CoupNgay> lesCoupsPossibles = coupsPossibles(joueur);        if (!lesCoupsPossibles.isEmpty()) {            for (CoupNgay c : lesCoupsPossibles) {                CoupNgay ca = c;                int indiceTrou = ca.getIndiceTrou();                if ((trous[indiceTrou].isPropriétaire(joueur) && trous[indiceTrou].getNbGraines() > 1)) {                    return false;                }            }        }        return true;    }    public PlateauNgay copy() {        return new PlateauNgay(getJoueurAdverse(vientDeJouer), trous, score);    }    public boolean coupValide(Joueur joueur, CoupNgay c) {        CoupNgay ca = c;        int indiceTrou = ca.getIndiceTrou();        return (trous[indiceTrou].isPropriétaire(joueur) && (trous[indiceTrou].getNbGraines() > 1) && (trous[indiceTrou]).isTrousSimple() || trous[indiceTrou].isPropriétaire(joueur) && (trous[indiceTrou].getNbGraines() >= 9) && (trous[indiceTrou]).isTrousStockageESept() || trous[indiceTrou].isPropriétaire(joueur) && (trous[indiceTrou].getNbGraines() >= 7) && (trous[indiceTrou]).isTrousStockageECinq());    }    /* ********************* Autres méthodes ***************** */    public void addToScore(int points, Joueur j) {        score[joueurToInt(j)] += points;    }    public int nbGrainesRestantes() {        int reste = 0;        for (int i = 0; i < 10; i++) {            reste += trous[i].getNbGraines();        }        return reste;    }    /**     * Utilisée pour le calcul de l'heuristique : Calcule la différence entre le     * nombre de graines capturées par le joueur Ami et le nombre de graines     * capturées par l’adversaire. Si la partie se termine, elle retourne     * MAX_VALUE si l’on a gagné, - MAX_VALUE si on a perdu, et 0 en cas de     * match nul. *     */    public float[] evaluation(PlateauNgay pNgay, Joueur j) {        float[] v = new float[3];        v[0] = 0;        v[1] = 0;        v[2] = 0;        if (pNgay.nbGrainesRestantes() == 50) {            return v;        } else if (pNgay.isJoueur1(j)) {            v[0] = ((pNgay.getScore(j)) - ((pNgay.getScore(getJoueurAdverse(j))) + (pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))))));            v[1] = (pNgay.getScore(getJoueurAdverse(j))) - ( (pNgay.getScore(j)) + pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))) );            v[2] = (pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j)))) - ( pNgay.getScore(getJoueurAdverse(j)) + pNgay.getScore(j));            return v;        } else if (pNgay.isJoueur2(j)) {            v[1] = (pNgay.getScore(j)) - ( pNgay.getScore(getJoueurAdverse(j)) + pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))) );            v[2] = (pNgay.getScore(getJoueurAdverse(j)) - ( pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))) + pNgay.getScore(j) ));            v[0] = ((pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))))) - ((pNgay.getScore(j)) + (pNgay.getScore(getJoueurAdverse(j))));            return v;        } else {            v[2] = (pNgay.getScore(j) - ( pNgay.getScore(getJoueurAdverse(j)) + pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))) ));            v[0] = ((pNgay.getScore(getJoueurAdverse(j))) - ((pNgay.getScore(j) + (pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j)))))));            v[1] = (pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))) - ( pNgay.getScore(j) + pNgay.getScore(getJoueurAdverse(j)) ));            return v;        }        //debut//        if (pNgay.nbGrainesRestantes() == 50) {//            return v;//        } else if (pNgay.isJoueur1(j)) {////            v[0] = ((pNgay.getScore(j)) - ((pNgay.getScore(getJoueurAdverse(j))) + (pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))))));//            v[1] = (pNgay.getScore(getJoueurAdverse(j))) ;//- ( (pNgay.getScore(j)) + pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))) );//            v[2] = (pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j)))) ;//- ( pNgay.getScore(getJoueurAdverse(j)) + pNgay.getScore(j));//            return v;//        } else if (pNgay.isJoueur2(j)) {//            v[1] = (pNgay.getScore(j)) - ( pNgay.getScore(getJoueurAdverse(j)) + pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))) );//            v[2] = pNgay.getScore(getJoueurAdverse(j)) ;//- ( pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))) + pNgay.getScore(j) ));//            v[0] = ((pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))))) ;//- ((pNgay.getScore(j)) + (pNgay.getScore(getJoueurAdverse(j))));//            return v;//        } else {//            v[2] = (pNgay.getScore(j) - ( pNgay.getScore(getJoueurAdverse(j)) + pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j))) ));//            v[0] = (pNgay.getScore(getJoueurAdverse(j)));// - ((pNgay.getScore(j) + (pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j)))))));//            v[1] = pNgay.getScore(getJoueurAdverse(getJoueurAdverse(j)));// - ( pNgay.getScore(j) + pNgay.getScore(getJoueurAdverse(j)) ));//            return v;//        }        //fin    }    /**     * Next player after player     */    public static Joueur next_Player(Joueur player) {        if (isJoueur1(player)) {            return joueur2;        } else if (isJoueur2(player)) {            return joueur3;        } else {            return joueur1;        }    }    /**     * Relie les trous du tableau trous entre eux en assignant leurs voisins     * gauche et droite     */    private void assignerVoisins() {        trous[0].setVoisinGauche(trous[9]);        trous[0].setVoisinDroit(trous[1]);        for (int i = 1; i < 9; i++) {            trous[i].setVoisinGauche(trous[i - 1]);            trous[i].setVoisinDroit(trous[i + 1]);        }        trous[9].setVoisinGauche(trous[8]);        trous[9].setVoisinDroit(trous[0]);    }    @Override    public String toString() {        String retstr = "";        for (int i = 4; i >= 0; i--) {            retstr += " " + trous[i].getNbGraines();        }        retstr += "\n";        for (int i = 5; i < 10; i++) {            retstr += " " + trous[i].getNbGraines();        }        return retstr;    }    /**     * Joue "pour du beurre" le coup c, c'est-à-dire que ce coup peut affamer     * l'adversaire. C'est un intermédiaire pour déterminer si le coup c devrait     * affamer l'adversaire     */    private void joueBeurre(Joueur j, CoupJeu c) {        CoupNgay ca = (CoupNgay) c;        int indiceTrou = ca.getIndiceTrou();        trous[indiceTrou].declencherCoup(j);    }    /**     *     * Jouer AI     *     */    public void jouerAI(Joueur player, AlgoJeu[] al) {        if (!pasDeCoupPossibles(player)) {            launchGameAI(player, al);            if ((pasDeCoupPossibles(PlateauNgay.getJoueur2())) && (pasDeCoupPossibles(PlateauNgay.getJoueur3()))) {                jouerAI(player, al);            } else {                if (pasDeCoupPossibles(PlateauNgay.getJoueur2())) {                    currentPlayer = PlateauNgay.next_Player(PlateauNgay.getJoueur2());                } else {                    currentPlayer = PlateauNgay.next_Player(PlateauNgay.getJoueur1());                }            }        } else {            updateTableGame(player);            if (PlateauNgay.partieNumberOld == PlateauNgay.partieNumber) {                if (finPartieNgay()) {                    // nextLJoueur.setText("GAME OVER ");                    System.out.println("game over");                }            } else {                if (currentPlayer.equals(next_Player(player))) {                    if (pasDeCoupPossibles(next_Player(player))) {                        currentPlayer = next_Player(currentPlayer);                    }                    if (currentPlayer.equals(joueur1) || pasDeCoupPossibles(currentPlayer)) {                        jouerAI(joueur1, al);                    }                } else {                    currentPlayer = joueurQCom;                    if (currentPlayer.equals(PlateauNgay.getJoueur1())) {                        jouerAI(PlateauNgay.getJoueur1(), al);                    }                }            }        }    }    /**     *     * Jouer Player     *     */    public void jouerPlayer(Joueur player, AlgoJeu[] al, CoupNgay coup) {        if (!pasDeCoupPossibles(player)) {            ArrayList<CoupNgay> lesCoupsPossibles = coupsPossibles(player);            boolean exite = false;            for (CoupNgay coupJoue : lesCoupsPossibles) {                if (coup.getIndiceTrou() == coupJoue.getIndiceTrou()) {                    exite = true;                    break;                }            }            if (exite == true) {                launchGamePlayer(player, coup);                // if (!((pasDeCoupPossibles(PlateauNgay.getJoueur1())) && (pasDeCoupPossibles(player)))) {                currentPlayer = next_Player(player);                if (currentPlayer.equals(PlateauNgay.getJoueur1()) || pasDeCoupPossibles(currentPlayer)) {                    jouerAI(PlateauNgay.getJoueur1(), al);                }                // }            } else {                System.out.println("Desole ce coup ne vous appartient pas...");            }        } else {            updateTableGame(player);            if (finPartieNgay()) {                if (PlateauNgay.partieNumberOld == PlateauNgay.partieNumber) {                    //nextLJoueur.setText("GAME OVER ");                    System.out.println("Game over ....");                }            } else {                if (currentPlayer.equals(next_Player(player))) {                    if (pasDeCoupPossibles(next_Player(player))) {                        currentPlayer = next_Player(currentPlayer);                    }                    if (currentPlayer.equals(joueur1) || pasDeCoupPossibles(currentPlayer)) {                        jouerAI(joueur1, al);                    }                }else{                    currentPlayer = joueurQCom;                    if (currentPlayer.equals(PlateauNgay.getJoueur1())|| pasDeCoupPossibles(currentPlayer)) {                        jouerAI(PlateauNgay.getJoueur1(), al);                    }                }            }        }    }}